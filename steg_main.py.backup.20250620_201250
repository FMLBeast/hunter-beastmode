#!/usr/bin/env python3
"""
StegAnalyzer - Advanced Steganography Detection & Analysis Framework
GPU-Powered, AI-Augmented, Massively Parallel Steganography Analysis Tool
"""

import asyncio
import logging
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional
import argparse
import json
from datetime import datetime

# Import core components
from core.orchestrator import StegOrchestrator
from config.steg_config import Config
from core.database import DatabaseManager

# Optional imports with graceful handling
try:
    from core.dashboard import Dashboard
except ImportError as e:
    print(f"Warning: Dashboard not available: {e}")
    Dashboard = None

try:
    from core.reporter import ReportGenerator
except ImportError as e:
    print(f"Warning: ReportGenerator not available: {e}")
    ReportGenerator = None

def setup_logging(level=logging.INFO):
    """Setup logging configuration"""
    logging.basicConfig(
        level=level,
        format="%(asctime)s %(levelname)s %(name)s - %(message)s"
    )
    logging.getLogger("steg_main").info("Logging initialized.")

class SystemChecker:
    @staticmethod
    async def check_all():
        """Check all system requirements"""
        status = {
            "python_version": sys.version,
            "platform": sys.platform,
            "tools": {},
            "dependencies": {},
            "gpu": {"available": False, "cuda": False}
        }
        
        # Check external tools
        import subprocess
        tools = ["steghide", "outguess", "zsteg", "binwalk", "exiftool", "strings"]
        for tool in tools:
            try:
                result = subprocess.run([tool, "--version"], capture_output=True, timeout=5)
                status["tools"][tool] = result.returncode == 0
            except:
                status["tools"][tool] = False
        
        # Check Python dependencies
        deps = ["PIL", "numpy", "scipy", "magic", "yara"]
        for dep in deps:
            try:
                __import__(dep)
                status["dependencies"][dep] = True
            except ImportError:
                status["dependencies"][dep] = False
        
        # Check GPU
        try:
            import torch
            status["gpu"]["available"] = torch.cuda.is_available()
            status["gpu"]["cuda"] = torch.version.cuda if torch.cuda.is_available() else None
        except ImportError:
            pass
        
        return status

class StegAnalyzer:
    def __init__(self, config_path: str = "config/default.json"):
        """Initialize StegAnalyzer with proper configuration handling"""
        self.config = Config(config_path)
        self.logger = logging.getLogger(__name__)
        
        # Convert config to dict for components that need it
        config_dict = self.config.to_dict()
        
        # Initialize database with proper config
        db_config = config_dict.get("database", {"type": "sqlite", "path": "data/steganalyzer.db"})
        self.db = DatabaseManager(db_config)
        
        # Initialize orchestrator with full config dict and database instance
        self.orchestrator = StegOrchestrator(config_dict, self.db)
        
        # Initialize optional components
        if Dashboard:
            self.dashboard = Dashboard(config_dict, self.db)
        else:
            self.dashboard = None
            
        if ReportGenerator:
            self.reporter = ReportGenerator(config_dict, self.db)
        else:
            self.reporter = None
        
        self.logger.info("StegAnalyzer initialized successfully")
        
    async def analyze_file(self, file_path: str, target_dir: str = None) -> Dict[str, Any]:
        """Analyze a single file for steganographic content"""
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
            
        # Create analysis session
        session_id = await self.db.create_session(
            target_path=str(file_path),
            target_dir=target_dir,
            config=self.config.to_dict()
        )
        
        self.logger.info(f"Starting analysis session {session_id} for {file_path}")
        
        # Start dashboard if enabled and available
        dashboard_url = None
        if self.dashboard and self.config.dashboard.enabled:
            try:
                await self.dashboard.start(session_id)
                dashboard_url = f"http://{self.config.dashboard.host}:{self.config.dashboard.port}"
            except Exception as e:
                self.logger.warning(f"Could not start dashboard: {e}")
        
        try:
            # Run orchestrated analysis
            results = await self.orchestrator.analyze(file_path, session_id)
            
            # Generate report if reporter is available
            report = None
            if self.reporter:
                try:
                    report = await self.reporter.generate_report(session_id)
                except Exception as e:
                    self.logger.warning(f"Could not generate report: {e}")
                    report = {"path": "Report generation failed", "error": str(e)}
            
            self.logger.info(f"Analysis complete. Found {len(results)} findings.")
            
            return {
                "session_id": session_id,
                "target_path": str(file_path),
                "files_analyzed": 1,
                "results": results,
                "report_path": report.get("path") if report else None,
                "dashboard_url": dashboard_url
            }
            
        except Exception as e:
            self.logger.error(f"Analysis failed: {e}")
            # Update session status to failed
            await self._update_session_status(session_id, "failed", str(e))
            raise
        finally:
            # Stop dashboard if it was started
            if self.dashboard and dashboard_url:
                try:
                    await self.dashboard.stop()
                except Exception as e:
                    self.logger.warning(f"Error stopping dashboard: {e}")
    
    async def analyze_directory(self, directory_path: str) -> Dict[str, Any]:
        """Analyze all files in a directory"""
        directory_path = Path(directory_path)
        if not directory_path.exists() or not directory_path.is_dir():
            raise ValueError(f"Directory not found: {directory_path}")
        
        # Find all files to analyze
        files_to_analyze = []
        for file_path in directory_path.rglob("*"):
            if file_path.is_file() and not file_path.name.startswith('.'):
                files_to_analyze.append(file_path)
        
        if not files_to_analyze:
            raise ValueError(f"No files found in directory: {directory_path}")
        
        # Create analysis session for the directory
        session_id = await self.db.create_session(
            target_path=str(directory_path),
            target_dir=str(directory_path),
            config=self.config.to_dict()
        )
        
        self.logger.info(f"Starting directory analysis session {session_id} for {len(files_to_analyze)} files")
        
        # Start dashboard if enabled and available
        dashboard_url = None
        if self.dashboard and self.config.dashboard.enabled:
            try:
                await self.dashboard.start(session_id)
                dashboard_url = f"http://{self.config.dashboard.host}:{self.config.dashboard.port}"
            except Exception as e:
                self.logger.warning(f"Could not start dashboard: {e}")
        
        try:
            # Analyze all files
            all_results = []
            for file_path in files_to_analyze:
                try:
                    file_results = await self.orchestrator.analyze(file_path, session_id)
                    all_results.extend(file_results)
                    self.logger.info(f"Completed analysis of {file_path}")
                except Exception as e:
                    self.logger.error(f"Failed to analyze {file_path}: {e}")
                    continue
            
            # Generate report if reporter is available
            report = None
            if self.reporter:
                try:
                    report = await self.reporter.generate_report(session_id)
                except Exception as e:
                    self.logger.warning(f"Could not generate report: {e}")
                    report = {"path": "Report generation failed", "error": str(e)}
            
            self.logger.info(f"Directory analysis complete. Found {len(all_results)} total findings.")
            
            return {
                "session_id": session_id,
                "target_path": str(directory_path),
                "files_analyzed": len(files_to_analyze),
                "results": all_results,
                "report_path": report.get("path") if report else None,
                "dashboard_url": dashboard_url
            }
            
        except Exception as e:
            self.logger.error(f"Directory analysis failed: {e}")
            await self._update_session_status(session_id, "failed", str(e))
            raise
        finally:
            # Stop dashboard if it was started
            if self.dashboard and dashboard_url:
                try:
                    await self.dashboard.stop()
                except Exception as e:
                    self.logger.warning(f"Error stopping dashboard: {e}")
    
    async def resume_session(self, session_id: str) -> Dict[str, Any]:
        """Resume an interrupted analysis session"""
        session = await self.db.get_session(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        self.logger.info(f"Resuming session {session_id}")
        
        # Update config if needed
        if session.get('config'):
            # Merge session config with current config
            session_config = session['config']
            if isinstance(session_config, str):
                session_config = json.loads(session_config)
            # Update current config with session config
            current_config = self.config.to_dict()
            current_config.update(session_config)
        
        # Continue analysis from where it left off
        target_path = Path(session['target_path'])
        
        if target_path.is_file():
            results = await self.analyze_file(str(target_path), session.get('target_dir'))
        elif target_path.is_dir():
            results = await self.analyze_directory(str(target_path))
        else:
            raise ValueError(f"Target path no longer exists: {target_path}")
        
        return results
    
    async def get_session_results(self, session_id: str) -> Dict[str, Any]:
        """Get results for a completed session"""
        session = await self.db.get_session(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        results = await self.db.get_session_results(session_id)
        
        return {
            "session_id": session_id,
            "status": session["status"],
            "results": results,
            "created_at": session["created_at"],
            "completed_at": session.get("completed_at")
        }
    
    async def list_sessions(self) -> List[Dict[str, Any]]:
        """List all analysis sessions"""
        return await self.db.list_sessions()
    
    async def _update_session_status(self, session_id: str, status: str, error_message: str = None):
        """Update session status"""
        # This is a helper method to update session status
        # Implementation depends on your database schema
        pass
    
    async def cleanup(self):
        """Cleanup resources"""
        try:
            await self.db.close()
        except Exception as e:
            self.logger.error(f"Error closing database: {e}")
        
        if self.dashboard:
            try:
                await self.dashboard.stop()
            except Exception as e:
                self.logger.error(f"Error stopping dashboard: {e}")

async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="StegAnalyzer - Advanced Steganography Detection Framework"
    )
    
    # Make target optional by using nargs='?'
    parser.add_argument("target", nargs="?", help="File or directory to analyze")
    parser.add_argument("-c", "--config", default="config/default.json", help="Configuration file")
    parser.add_argument("-o", "--output", help="Output directory for results")
    parser.add_argument("-r", "--resume", help="Resume session ID")
    parser.add_argument("-l", "--list-sessions", action="store_true", help="List all sessions")
    parser.add_argument("-s", "--session-results", help="Get results for session ID")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose logging")
    parser.add_argument("--check-system", action="store_true", help="Check system requirements")
    
    args = parser.parse_args()
    
    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    setup_logging(level=log_level)
    
    # Handle operations that don't require a target
    if args.check_system:
        checker = SystemChecker()
        status = await checker.check_all()
        print(json.dumps(status, indent=2))
        return 0
    
    if args.list_sessions:
        try:
            analyzer = StegAnalyzer(args.config)
            sessions = await analyzer.list_sessions()
            print(json.dumps(sessions, indent=2, default=str))
            await analyzer.cleanup()
            return 0
        except Exception as e:
            print(f"Error listing sessions: {e}")
            return 1
    
    if args.session_results:
        try:
            analyzer = StegAnalyzer(args.config)
            results = await analyzer.get_session_results(args.session_results)
            print(json.dumps(results, indent=2, default=str))
            await analyzer.cleanup()
            return 0
        except Exception as e:
            print(f"Error getting session results: {e}")
            return 1
    
    if args.resume:
        try:
            analyzer = StegAnalyzer(args.config)
            results = await analyzer.resume_session(args.resume)
            print(f"\nAnalysis resumed!")
            print(f"Session ID: {results['session_id']}")
            print(f"Results found: {len(results.get('results', []))}")
            if 'report_path' in results:
                print(f"Report: {results['report_path']}")
            if 'dashboard_url' in results and results['dashboard_url']:
                print(f"Dashboard: {results['dashboard_url']}")
            await analyzer.cleanup()
            return 0
        except Exception as e:
            print(f"Error resuming session: {e}")
            return 1
    
    # For analysis operations, target is required
    if not args.target:
        print("Error: target file or directory is required for analysis")
        print("Use --help for usage information")
        return 1
    
    try:
        analyzer = StegAnalyzer(args.config)
        
        target_path = Path(args.target)
        if target_path.is_file():
            results = await analyzer.analyze_file(args.target, args.output)
        elif target_path.is_dir():
            results = await analyzer.analyze_directory(args.target)
        else:
            print(f"Error: {args.target} is not a valid file or directory")
            return 1
        
        print(f"\nAnalysis completed!")
        print(f"Session ID: {results['session_id']}")
        print(f"Results found: {len(results.get('results', []))}")
        if 'report_path' in results:
            print(f"Report: {results['report_path']}")
        if 'dashboard_url' in results and results['dashboard_url']:
            print(f"Dashboard: {results['dashboard_url']}")
        
        await analyzer.cleanup()
        return 0
            
    except KeyboardInterrupt:
        print("\nAnalysis interrupted by user")
        return 130
    except Exception as e:
        logging.error(f"Analysis failed: {e}")
        return 1

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)